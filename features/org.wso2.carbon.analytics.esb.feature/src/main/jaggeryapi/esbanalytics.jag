<%
(function () {
    var TYPE = "type";
    var CONTENT_TYPE_JSON = "application/json";
    var AUTHORIZATION_HEADER = "Authorization";
    var USER_TOKEN = "user";
    var USERNAME = "username";
    var HTTP_USER_NOT_AUTHENTICATED = 403;
    var HTTP_INTERNAL_ERROR = 500;
    var log = new Log();
    var carbon = require('carbon');
    var configs = require('/configs/designer.json');
    var utils = require('/modules/utils.js');
    var JSUtils = Packages.org.wso2.carbon.analytics.jsservice.Utils;
    var AnalyticsCachedJSServiceConnector = Packages.org.wso2.carbon.analytics.jsservice.AnalyticsCachedJSServiceConnector;
    var AnalyticsCache = Packages.org.wso2.carbon.analytics.jsservice.AnalyticsCachedJSServiceConnector.AnalyticsCache;
    var cacheTimeoutSeconds = 5;
    var loggedInUser = null;
    var timeRangeUtil = Packages.org.wso2.carbon.analytics.esb.util.TimeRangeUtils;
    var timeRange = Packages.org.wso2.carbon.analytics.esb.bean.TimeRange;

    //operation types
    var TYPE_OVERALL_TPS = 1;
    var TYPE_OVERALL_MESSAGE_COUNT = 2;
    var TYPE_OVERALL_FAULT_COUNT = 3;
    var TYPE_TOP_INVOKED_PROXIES = 4;
    var TYPE_TOP_INVOKED_APIS = 5;
    var TYPE_PROXY_NAMES = 6;
    var TYPE_PROXY_MESSAGE_RATE = 7;
    var TYPE_PROXY_LATENCY = 8;
    var TYPE_PROXY_MESSAGES = 9;
    var TYPE_PROXY_MESSAGE_FLOW = 10;
    var TYPE_API_NAMES = 11;
    var TYPE_API_MESSAGE_RATE = 12;
    var TYPE_API_LATENCY = 13;
    var TYPE_API_MESSAGES = 14;
    var TYPE_API_MESSAGE_FLOW = 15;
    var TYPE_MEDIATOR_NAMES = 16;
    var TYPE_MEDIATOR_MESSAGE_RATE = 17;
    var TYPE_MEDIATOR_LATENCY = 18;
    var TYPE_MEDIATOR_MESSAGES = 19;
    var TYPE_MESSAGE_FLOW = 22;
    var TYPE_MESSAGE_LIST = 23;
    var TYPE_ENDPOINT_NAMES = 24;
    var TYPE_ENDPOINT_MESSAGE_RATE = 25;
    var TYPE_ENDPOINT_LATENCY = 26;
    var TYPE_ENDPOINT_MESSAGES = 27;
    var TYPE_SEQUENCE_NAMES = 28;
    var TYPE_SEQUENCE_MESSAGE_RATE = 29;
    var TYPE_SEQUENCE_LATENCY = 30;
    var TYPE_SEQUENCE_MESSAGES = 31;
    var TYPE_SEQUENCE_MESSAGE_FLOW = 32;
    var TYPE_INBOUND_ENDPOINT_NAMES = 33;
    var TYPE_INBOUND_ENDPOINT_MESSAGE_RATE = 34;
    var TYPE_INBOUND_ENDPOINT_LATENCY = 35;
    var TYPE_INBOUND_ENDPOINT_MESSAGES = 36;
    var TYPE_INBOUND_ENDPOINT_MESSAGE_FLOW = 37;
    var TYPE_OVERALL_STATS = 38;
    var TYPE_PROXY_STATS = 39;
    var TYPE_API_STATS = 40;
    var TYPE_SEQUENCE_STATS = 41;
    var TYPE_MEDIATOR_STATS = 42;
    var TYPE_ENDPOINT_STATS = 43;
    var TYPE_INBOUND_ENDPOINT_STATS = 44;
    var TYPE_TOP_INVOKED_ENDPOINTS = 45;
    var TYPE_TOP_INVOKED_INBOUNDS = 46;
    var TYPE_TOP_INVOKED_SEQUENCES = 47;


    if (configs.cacheTimeoutSeconds) {
        cacheTimeoutSeconds = parseInt(configs.cacheTimeoutSeconds);
    }
    var cacheSizeBytes = 1024 * 1024 * 1024; // 1GB
    if (configs.cacheSizeBytes) {
        cacheSizeBytes = parseInt(configs.cacheSizeBytes);
    }

    response.contentType = CONTENT_TYPE_JSON;

    var authParam = request.getHeader(AUTHORIZATION_HEADER);
    if (authParam != null) {
        credentials = JSUtils.authenticate(authParam);
        loggedInUser = credentials[0];
    } else {
        var token = session.get(USER_TOKEN);
        if (token != null) {
            loggedInUser = token[USERNAME];
        } else {
            log.error("user is not authenticated!");
            response.status = HTTP_USER_NOT_AUTHENTICATED;
            print('{ "status": "Failed", "message": "User is not authenticated." }');
            return;
        }
    }

    var cache = application.get("AnalyticsWebServiceCache");
    if (cache == null) {
        cache = new AnalyticsCache(cacheTimeoutSeconds, cacheSizeBytes);
        application.put("AnalyticsWebServiceCache", cache);
    }

    var connector = new AnalyticsCachedJSServiceConnector(cache);

    var type = 0;
    var typeParam = request.getParameter(TYPE);
    if (typeParam != null) {
        type = parseInt(typeParam);
    }

    if (type == 0) {
        log.error("operation type is not specified!");
        response.status = HTTP_INTERNAL_ERROR;
        print('{ "status": "Failed", "message": "Operation type is not specified" }');
        return;
    }

    var content = request.getContent();
    if (content != '' && content != null) {
        if (log.isDebugEnabled()) {
            log.debug("value of content: " + stringify(contentAsString));
        }
    }
    if (connector != null && loggedInUser != null) {
        var result = null;
        var query = null;
        var resp = null;
        switch (type) {
            case TYPE_OVERALL_TPS:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "ESB-STAT-PER-" + timeUnit;
                query = stringify({
                    tableName: tableName,
                    groupByField: "facetStartTime",
                    query: "startingTime : [" + timeFrom + " TO " + timeTo + "]",
                    aggregateFields: [
                        {
                            fields: ["noOfInvocation"],
                            aggregate: "SUM",
                            alias: "total_invocation_sum"
                        }
                    ],
                    aggregateLevel: 0,
                    parentPath: []
                });
                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                var divider = 1;
                if (timeUnit == 'MONTH') {
                    divider = 3600 * 24 * 30;
                } else if (timeUnit == 'DAY') {
                    divider = 3600 * 24;
                } else if (timeUnit == 'HOUR') {
                    divider = 3600;
                } else if (timeUnit == 'MINUTE') {
                    divider = 60;
                }
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (timeUnit == 'MONTH') {
                        divider = timeRangeUtil.getNoOfSecondForMonthInGivenTimestamp(obj.values.facetStartTime[0]);
                    }
                    result.push({
                        "timestamp": obj.values.facetStartTime[0],
                        "tps": obj.values.total_invocation_sum / divider
                    });
                }
                break;
            }
            case TYPE_OVERALL_MESSAGE_COUNT:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "ESB-STAT-PER-" + timeUnit;
                query = stringify({
                    tableName: tableName,
                    groupByField: "facetStartTime",
                    query: "startingTime : [" + timeFrom + " TO " + timeTo + "]",
                    aggregateFields: [
                        {
                            fields: ["noOfInvocation"],
                            aggregate: "SUM",
                            alias: "total_invocation_sum"
                        },
                        {
                            fields: ["faultCount"],
                            aggregate: "SUM",
                            alias: "total_fault_count"
                        }
                    ],
                    aggregateLevel: 0,
                    parentPath: []
                });
                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                        "timestamp": obj.values.facetStartTime[0],
                        "success": obj.values.total_invocation_sum,
                        "faults": obj.values.total_fault_count
                    });
                }
                break;
            }
            case TYPE_TOP_INVOKED_PROXIES:
            {
                var result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var tableName = "ESB-STAT-PER-MINUTE"
                var query = stringify({
                    "fieldName": "componentName",
                    "categoryPath": [],
                    "query": "startingTime : [" + timeFrom + " TO " + timeTo + "] AND componentType:\"Proxy Service\"",
                    "scoreFunction": "noOfInvocation"
                });
                var resp = connector.drillDownCategories(loggedInUser, tableName, query);
                var drillDownResult = JSON.parse(resp.getMessage());
                for (var key in drillDownResult["categories"]) {
                    if (drillDownResult["categories"].hasOwnProperty(key)) {
                        result.push({"name": key, "requests": drillDownResult["categories"][key]});
                    }
                }
                result = result.slice(0, 5);
                break;
            }
            case TYPE_TOP_INVOKED_APIS:
            {
                var result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var tableName = "ESB-STAT-PER-MINUTE"
                var query = stringify({
                    "fieldName": "componentName",
                    "categoryPath": [],
                    "query": "startingTime : [" + timeFrom + " TO " + timeTo + "] AND componentType:API",
                    "scoreFunction": "noOfInvocation"
                });
                var resp = connector.drillDownCategories(loggedInUser, tableName, query);
                var drillDownResult = JSON.parse(resp.getMessage());
                for (var key in drillDownResult["categories"]) {
                    if (drillDownResult["categories"].hasOwnProperty(key)) {
                        result.push({"name": key, "requests": drillDownResult["categories"][key]});
                    }
                }
                result = result.slice(0, 5);
                break;
            }
            case TYPE_PROXY_NAMES:
            {
                result = [];
                var tableName = "ESB-STAT-PER-MINUTE";
                query = stringify({
                                    "fieldName": "componentName",
                                    "query": "componentType : \"Proxy Service\""
                                  });
                resp = connector.drillDownCategories(loggedInUser, tableName, query);
                var proxyNames = JSON.parse(resp.getMessage());

                for (var name in proxyNames["categories"]) {
                    result.push(name);
                }
                break;
            }
            case TYPE_PROXY_MESSAGE_RATE:
            {
                result = [];
                var timeUnit = 'MINUTE';
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var proxyName = request.getParameter("id");
                if (timeFrom && timeTo) {
                    timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                    query = "componentType : \"Proxy Service\" AND _componentName : \"" + proxyName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                } else {
                    query = "componentType : \"Proxy Service\" AND _componentName : \"" + proxyName + "\"";
                }
                var tableName = "ESB-STAT-PER-" + timeUnit;
                query = stringify({
                    tableName: tableName,
                    groupByField: "facetStartTime",
                    query: query,
                    aggregateFields: [
                        {
                            fields: ["noOfInvocation"],
                            aggregate: "SUM",
                            alias: "total_invocation_sum"
                        },
                        {
                            fields: ["faultCount"],
                            aggregate: "SUM",
                            alias: "total_fault_count"
                        }
                    ],
                    aggregateLevel: 0,
                    parentPath: []
                });
    
                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                        "timestamp": obj.values.facetStartTime[0],
                        "success": obj.values.total_invocation_sum,
                        "faults": obj.values.total_fault_count
                    });
                }
                break;
            }
            case TYPE_PROXY_LATENCY:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "ESB-STAT-PER-" + timeUnit;
                var proxyName = request.getParameter("id");
                query = stringify({
                    tableName: tableName,
                    query: "startingTime : [" + timeFrom + " TO " + timeTo + "] AND componentType:\"Proxy Service\" AND _componentName : \"" + proxyName + "\"",
                    start: 0,
                    count: 60
                });
                resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                        "timestamp": obj.values.facetStartTime,
                        "min": obj.values.minDuration,
                        "max": obj.values.maxDuration,
                        "avg": obj.values.totalDuration / obj.values.noOfInvocation
                    });
                }
                break;
            }
            case TYPE_PROXY_MESSAGE_FLOW:
            {
                var result = [];
                var entryName = request.getParameter("id");
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                // get schema 
                var tableName = "ESB-CONFIG-ENTRY-STREAM";
                var query = stringify({
                                      "query": "_entryName : \"" + entryName + "\" AND _timestamp : [0000000000 TO " + timeTo + "] ",
                                      "start": 0,
                                      "count": 100,
                                      "sortBy" : [
                                            {
                                                "field" : "_timestamp",
                                                "sortType" : "DESC",
                                                "reversed" : "false"
                                            }
                                        ]
                                  });
                var resp = connector.search(loggedInUser, tableName, query);
                var config = JSON.parse(resp.getMessage())[0];
                if (config != null) {
                    var schema = JSON.parse(config["values"]["configData"]);
                    var entryHashCode = config["values"]["hashcode"];

                    // get components info from different tables
                    var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                    var searchParams = [];
                    var aggregateFields = [];
                    aggregateFields.push({fields: ["totalDuration"], aggregate: "SUM", alias: "TotalDuration"});
                    aggregateFields.push({fields: ["totalDuration"], aggregate: "MAX", alias: "MaxDuration"});
                    aggregateFields.push({fields: ["noOfInvocation"], aggregate: "SUM", alias: "Invocations"});
                    aggregateFields.push({fields: ["faultCount"], aggregate: "SUM", alias: "Faults"});
                    aggregateFields.push({fields: ["entryPoint"], aggregate: "FIRST", alias: "entryPoint"});
                    aggregateFields.push({fields: ["componentType"], aggregate: "FIRST", alias: "componentType"});
                    for (var i = 0; i < timeRanges.size(); i++) {
                        timeRange = timeRanges.get(i);
                        var searchParam = {
                            tableName: "MEDIATOR-STAT-PER-" + timeRange.unit,
                            groupByField: "componentId",
                            query: "entryPointHashcode : \"" + entryHashCode + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "}",
                            aggregateLevel: 0,
                            parentPath: [],
                            noOfRecords : 10000
                        }
                        searchParam.aggregateFields = aggregateFields;
                        searchParams.push(searchParam);
                    }
                    var resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));           
                    var allTables = JSON.parse(resp.getMessage());

                    // Aggregate all tables and prepare component map
                    var componentMap = {};
                    var fields = ["Invocations", "TotalDuration", "MaxDuration", "Faults"];
                    for (var i = 0; i < allTables.length; i++) {
                        var table = allTables[i];
                        if (table != null && table.length != 0) {
                            for (var j = 0; j < table.length; j++) {
                                var componentInfo = table[j]["values"];
                                var componentId = componentInfo["componentId"][0];
                                if (componentMap[componentId] == null) {
                                    componentMap[componentId] = componentInfo;
                                } else {
                                    for (field in fields) {
                                        fieldName = fields[field];
                                        componentMap[componentId][fieldName] = componentMap[componentId][fieldName] + componentInfo[fieldName];
                                    }
                                } 
                            }
                        }
                    }

                    // Populate tabel data
                    var componentNameRegex = new RegExp("^.*@\\d*:(.*)");
                    var groups = [];
                    for (var i = 0; i < schema.length; i++) {
                        var groupLabel;
                        var groupId = schema[i]["group"];
                        var componentId = schema[i]["id"];
                        var componentInfo = componentMap[componentId];
                        var dataAttributes = [];

                        // Find unique groups
                        if (schema[i]["group"] != null && groups.indexOf(schema[i]["group"]) == -1) {
                            groups.push(schema[i]["group"]);
                        }
                        
                        // Create data attributes
                        for (field in fields) {
                            var fieldName = fields[field];
                            if (componentInfo != null) {
                                if (fieldName == "TotalDuration") {
                                    dataAttributes.push({ "name" : "AvgDuration", "value" : (componentInfo[fieldName]/componentInfo["Invocations"]).toFixed(2)});
                                } else {
                                    dataAttributes.push({ "name" : fieldName, "value" : componentInfo[fieldName]});
                                }
                            } else {
                                dataAttributes.push({ "name" : fieldName, "value" : 0});
                            }  
                        }

                        var  componentLabel = componentNameRegex.exec(componentId)[1];
                        if (componentInfo != null ) {
                            componentType = componentInfo["componentType"];
                        } else {
                            componentType = "UNKNOWN";
                        }

                        // Create hidden attributes
                        var hiddenAttributes = [];
                        hiddenAttributes.push({"name" : "entryPoint", "value": entryName});
                        if (componentType == "Endpoint" || componentType == "Sequence") {
                            hiddenAttributes.push({ "name" : "id", "value": componentLabel});
                        } else {
                            hiddenAttributes.push({ "name" : "id", "value": componentId});
                        }

                        if (schema[i]["parentId"] == schema[i]["group"]) {
                            result.push({"id":componentId,
                                        "label" : componentLabel,
                                        "parents" : [],
                                        "group" : schema[i]["group"],
                                        "type": componentType,
                                        "dataAttributes":dataAttributes,
                                        "hiddenAttributes":hiddenAttributes
                                        });
                        } else {
                            result.push({"id":componentId,
                                        "label" : componentLabel,
                                        "parents" : [schema[i]["parentId"]],
                                        "group" : schema[i]["group"],
                                        "type": componentType,
                                        "dataAttributes":dataAttributes,
                                        "hiddenAttributes":hiddenAttributes
                                        });
                        }
                    }
                    // Defining groups
                    for (var j = 0 ; j < result.length ; j++) {
                        if(groups.indexOf(result[j]["id"]) >= 0) {
                            result[j]["type"] = "group";
                        }
                    }
                }
                break;
            }
            case TYPE_PROXY_MESSAGES:
            {
                var result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var proxyName = request.getParameter("id");
                var tableName = "ESB-EVENT";
                var query = stringify({
                                      "query": "componentType : \"Proxy Service\" AND _componentName : \"" + proxyName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                var resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                var columns = ["messageFlowId", "transportPropertyMap","faultCount","startTime","host"];
                for (i = 0 ; i < dataPoints.length ; i++) {
                    var temp = {};
                    for (j = 0 ; j < columns.length ; j++) {
                        var column = columns[j];
                        var value = dataPoints[i]["values"][column];
                        if (column == "transportPropertyMap" || column == "contextPropertyMap") {
                            temp[column] = stringify(value["map"]);
                        } else if (column == "faultCount") {
                            // Add message status
                            if (value > 0) {
                                temp["status"] = "Failed";
                            } else {
                                temp["status"] = "Success";
                            }   
                        }  else if (column == "startTime") {
                            var date = new Date(value);
                            temp[column] = date.toLocaleString();
                        } else {
                            temp[column] = value;
                        }
                    }
                    result.push(temp);
                }
                break;
            }
            case TYPE_API_NAMES:
            {
                result = [];
                var tableName = "ESB-STAT-PER-MINUTE";
                query = stringify({
                                    "fieldName": "componentName",
                                    "query": "componentType : API"
                                  });
                resp = connector.drillDownCategories(loggedInUser, tableName, query);
                var proxyNames = JSON.parse(resp.getMessage());

                for (var name in proxyNames["categories"]) {
                    result.push(name);
                }
                break;
            }
            case TYPE_API_MESSAGE_RATE:
            {
                result = [];
                var timeUnit = 'MINUTE';
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");

                var apiName = request.getParameter("id");
                if (timeFrom && timeTo) {
                    timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                    query = "componentType : API AND _componentName : \"" + apiName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                } else {
                    query = "componentType : API AND _componentName : \"" + apiName + "\"";
                }
                var tableName = "ESB-STAT-PER-" + timeUnit;
                query = stringify({
                    tableName: tableName,
                    groupByField: "facetStartTime",
                    query: query,
                    aggregateFields: [
                        {
                            fields: ["noOfInvocation"],
                            aggregate: "SUM",
                            alias: "total_invocation_sum"
                        },
                        {
                            fields: ["faultCount"],
                            aggregate: "SUM",
                            alias: "total_fault_count"
                        }
                    ],
                    aggregateLevel: 0,
                    parentPath: []
                });
                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                        "timestamp": obj.values.facetStartTime[0],
                        "success": obj.values.total_invocation_sum,
                        "faults": obj.values.total_fault_count
                    });
                }
                break;
            }
            case TYPE_API_LATENCY:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "ESB-STAT-PER-" + timeUnit;
                var apiName = request.getParameter("id");
                query = stringify({
                    tableName: tableName,
                    query: "startingTime : [" + timeFrom + " TO " + timeTo + "] AND componentType: API AND _componentName : \"" + apiName + "\"",
                    start: 0,
                    count: 60
                });
                resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                        "timestamp": obj.values.facetStartTime,
                        "min": obj.values.minDuration,
                        "max": obj.values.maxDuration,
                        "avg": obj.values.totalDuration / obj.values.noOfInvocation
                    });
                }
                break;
            }
            case TYPE_API_MESSAGE_FLOW:
            {
                result = ["Damn it! this needs to be thought..."];   
                break;
            }
            case TYPE_API_MESSAGES:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var apiName = request.getParameter("id");
                var tableName = "ESB-EVENT";
                query = stringify({
                                      "query": "componentType : API AND _componentName : \"" + apiName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                var resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());

                var columns = ["messageFlowId", "transportPropertyMap","faultCount","startTime","host"];
                for (i = 0 ; i < dataPoints.length ; i++) {
                    var temp = {};
                    for (j = 0 ; j < columns.length ; j++) {
                        var column = columns[j];
                        var value = dataPoints[i]["values"][column];
                        if (column == "transportPropertyMap" || column == "contextPropertyMap") {
                            temp[column] = stringify(value["map"]);
                        } else if (column == "faultCount") {
                            // Add message status
                            if (value > 0) {
                                temp["status"] = "Failed";
                            } else {
                                temp["status"] = "Success";
                            }   
                        }  else if (column == "startTime") {
                            var date = new Date(value);
                            temp[column] = date.toLocaleString();
                        } else {
                            temp[column] = value;
                        }
                    }
                    result.push(temp);
                }
                break;
            }
            case TYPE_MEDIATOR_NAMES:
            {
                var result = ["Foo", "Bar", "Baz"];
                break;
            }
            case TYPE_MEDIATOR_MESSAGE_RATE:
            {
                result = [];
                var timeUnit = 'MINUTE';
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentId = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                if (timeFrom && timeTo) {
                    timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                    query = "entryPoint : " + entryPoint + " AND _componentId : \"" + componentId + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                } else {
                    query = "entryPoint : " + entryPoint + " AND _componentId : \"" + componentId + "\"";
                }
                var tableName = "MEDIATOR-STAT-PER-" + timeUnit;
                query = stringify({
                    tableName: tableName,
                    groupByField: "facetStartTime",
                    query: query,
                    aggregateFields: [
                        {
                            fields: ["noOfInvocation"],
                            aggregate: "SUM",
                            alias: "total_invocation_sum"
                        },
                        {
                            fields: ["faultCount"],
                            aggregate: "SUM",
                            alias: "total_fault_count"
                        }
                    ],
                    aggregateLevel: 0,
                    parentPath: []
                });
                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                        "timestamp": obj.values.facetStartTime[0],
                        "success": obj.values.total_invocation_sum,
                        "faults": obj.values.total_fault_count
                    });
                }
                break;
            }
            case TYPE_MEDIATOR_LATENCY:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "MEDIATOR-STAT-PER-" + timeUnit;
                var componentId = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                query = stringify({
                    tableName: tableName,
                    query: "entryPoint : " + entryPoint + " AND _componentId : \"" + componentId + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]",
                    start: 0,
                    count: 60
                });
                resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                        "timestamp": obj.values.facetStartTime,
                        "min": obj.values.minDuration,
                        "max": obj.values.maxDuration,
                        "avg": obj.values.totalDuration / obj.values.noOfInvocation
                    });
                }
                break;
            }
            case TYPE_MEDIATOR_MESSAGES:
            {
                var result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentId = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                var tableName = "ESB-EVENT"; 
                var query = stringify({
                                      "query": "(componentType : Mediator OR  componentType : Sequence) AND _entryPoint : \"" + entryPoint + "\" AND _componentId : \"" + componentId + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                var resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                var columns = ["messageFlowId", "transportPropertyMap","faultCount","startTime","host"];
                for (i = 0 ; i < dataPoints.length ; i++) {
                    var temp = {};
                    for (j = 0 ; j < columns.length ; j++) {
                        var column = columns[j];
                        var value = dataPoints[i]["values"][column];
                        if (column == "transportPropertyMap" || column == "contextPropertyMap") {
                            temp[column] = stringify(value["map"]);
                        } else if (column == "faultCount") {
                            if (value > 0) {
                                temp["status"] = "Failed";
                            } else {
                                temp["status"] = "Success";
                            }   
                        }  else if (column == "startTime") {
                            var date = new Date(value);
                            temp[column] = date.toLocaleString();
                        } else {
                            temp[column] = value;
                        }
                    }
                    result.push(temp);
                }
                break;
            }
            case TYPE_MESSAGE_FLOW:
            {
                var result = [];
                var messageId = request.getParameter("id");
                var tableName = "ESB-EVENT";
                // Get Message details
                var query = stringify({
                    "tableName": tableName,
                    "query": "messageFlowId : \"" + messageId + "\"",
                    "start": 0,
                    "count" : 10000
                });
                var resp = connector.search(loggedInUser, tableName, query);           
                var components = JSON.parse(resp.getMessage());
                var entryPointHashCode = components[0]["values"]["entryPointHashcode"];
                var entryPoint = components[0]["values"]["entryPoint"];

                // Get schema 
                var tableName = "ESB-CONFIG-ENTRY-STREAM";
                var query = stringify({
                                      "query": "_hashcode : \"" + entryPointHashCode + "\"",
                                      "start": 0,
                                      "count": 1
                                  });
                var resp = connector.search(loggedInUser, tableName, query);
                var config = JSON.parse(resp.getMessage())[0];
                if (config != null) {
                    var schema = JSON.parse(config["values"]["configData"]);
                    // Prepare component map
                    var componentMap = {};
                    for (var i = 0; i < components.length; i++) {
                        var component = components[i];
                        var componentInfo = component["values"];
                        var componentId = componentInfo["componentId"];
                        componentMap[componentId] = componentInfo;
                    }

                    // Populate tabel data
                    var componentNameRegex = new RegExp("^.*@\\d*:(.*)");
                    var groups = [];
                    for (var i = 0; i < schema.length; i++) {
                        var groupLabel;
                        var groupId = schema[i]["group"];
                        var componentId = schema[i]["id"];
                        var componentInfo = componentMap[componentId];
                        var dataAttributes = [];
                        var hiddenAttributes = [];
                        var componentLabel = componentNameRegex.exec(componentId)[1];

                        // Find unique groups
                        if (schema[i]["group"] != null && groups.indexOf(schema[i]["group"]) == -1) {
                            groups.push(schema[i]["group"]);
                        }
                        
                        // Create data attributes
                        if (componentInfo != null) {
                            dataAttributes.push({ "name" : "Duration", "value" : componentInfo["duration"]});
                            if(componentInfo["faultCount"] == 0) {
                                dataAttributes.push({ "name" : "Status", "value" : "Success"});
                            } else {
                                dataAttributes.push({ "name" : "Status", "value" : "Failed"});
                            }
                            componentType = componentInfo["componentType"];
                        } else {
                            dataAttributes.push({ "name" : "Duration", "value" : "n/a"});
                            dataAttributes.push({ "name" : "Status", "value" : "n/a"});
                            componentType = "UNKNOWN";
                        }

                        // Create hidden attributes
                        hiddenAttributes.push({ "name" : "entryPoint", "value": entryPoint});
                        // for Sequences and Endpoints, id should be the "name", since name is used for drill down searches
                        if (componentType == "Endpoint" || componentType == "Sequence") {
                            hiddenAttributes.push({ "name" : "id", "value": componentLabel});
                        } else {
                            hiddenAttributes.push({ "name" : "id", "value": componentId});
                        }

                        if (schema[i]["parentId"] == schema[i]["group"]) {
                            result.push({"id":componentId,
                                        "label" : componentLabel,
                                        "parents" : [],
                                        "group" : schema[i]["group"],
                                        "type": componentType,
                                        "dataAttributes":dataAttributes,
                                        "hiddenAttributes":hiddenAttributes
                                        });
                        } else {
                            result.push({"id":componentId,
                                        "label" : componentLabel,
                                        "parents" : [schema[i]["parentId"]],
                                        "group" : schema[i]["group"],
                                        "type": componentType,
                                        "dataAttributes":dataAttributes,
                                        "hiddenAttributes":hiddenAttributes
                                        });
                        }
                    }
                    // Defining groups
                    for (var j = 0 ; j < result.length ; j++) {
                        if(groups.indexOf(result[j]["id"]) >= 0) {
                            result[j]["type"] = "group";
                        }
                    }
                }                
                break;
            }
            case TYPE_ENDPOINT_NAMES:
            {
                var result = [];
                var tableName = "ESB-STAT-PER-MINUTE";
                var query = stringify({
                                    "fieldName": "componentName",
                                    "query": "componentType : \"Endpoint\""
                                  });
                var resp = connector.drillDownCategories(loggedInUser, tableName, query);
                var proxyNames = JSON.parse(resp.getMessage());

                for (var name in proxyNames["categories"]) {
                    result.push(name);
                }
                break;
            }
            case TYPE_ENDPOINT_MESSAGE_RATE:
            {
                result = [];
                var timeUnit = 'MINUTE';
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                if (entryPoint == 'undefined') {
                    query = "_componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                } else {
                    query = "entryPoint : " + entryPoint + " AND _componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                }
                var tableName = "MEDIATOR-STAT-PER-" + timeUnit;
                query = stringify({
                                      tableName: tableName,
                                      groupByField: "facetStartTime",
                                      query: query,
                                      aggregateFields: [
                                          {
                                              fields: ["noOfInvocation"],
                                              aggregate: "SUM",
                                              alias: "total_invocation_sum"
                                          },
                                          {
                                              fields: ["faultCount"],
                                              aggregate: "SUM",
                                              alias: "total_fault_count"
                                          }
                                      ],
                                      aggregateLevel: 0,
                                      parentPath: []
                                  });
                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                                    "timestamp": obj.values.facetStartTime[0],
                                    "success": obj.values.total_invocation_sum,
                                    "faults": obj.values.total_fault_count
                                });
                }
                break;
            }
            case TYPE_ENDPOINT_LATENCY:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "MEDIATOR-STAT-PER-" + timeUnit;
                var componentName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                if (entryPoint == 'undefined') {
                    query = "_componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                } else {
                    query = "entryPoint : " + entryPoint + " AND _componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                }
                query = stringify({
                                      tableName: tableName,
                                      query: query,
                                      start: 0,
                                      count: 60
                                  });
                resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                                    "timestamp": obj.values.facetStartTime,
                                    "min": obj.values.minDuration,
                                    "max": obj.values.maxDuration,
                                    "avg": obj.values.totalDuration / obj.values.noOfInvocation
                                });
                }
                break;
            }
            case TYPE_ENDPOINT_MESSAGES:
            {
                var result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var endpointName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                var tableName = "ESB-EVENT";

                if (entryPoint != null && entryPoint != "undefined") {
                    var query = stringify({
                                      "query": "entryPoint : " + entryPoint + " AND componentType : \"Endpoint\" AND _componentName : \"" + endpointName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                } else {
                    var query = stringify({
                                      "query": "componentType : \"Endpoint\" AND _componentName : \"" + endpointName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                }
                
                var resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                var columns = ["messageFlowId", "faultCount","startTime","host"];
                for (i = 0 ; i < dataPoints.length ; i++) {
                    var temp = {};
                    for (j = 0 ; j < columns.length ; j++) {
                        var column = columns[j];
                        var value = dataPoints[i]["values"][column];
                        if (value != null && (column == "transportPropertyMap" || column == "contextPropertyMap")) {
                            temp[column] = stringify(value["map"]);
                        } else if (column == "faultCount") {
                            // Add message status
                            if (value > 0) {
                                temp["status"] = "Failed";
                            } else {
                                temp["status"] = "Success";
                            }   
                        }  else if (column == "startTime") {
                            var date = new Date(value);
                            temp[column] = date.toLocaleString();
                        } else {
                            temp[column] = value;
                        }
                    }
                    result.push(temp);
                }
                break;
            }
            case TYPE_SEQUENCE_NAMES:
            {
                var result = [];
                var excludeSequences = ["PROXY_INSEQ", "PROXY_OUTSEQ", "PROXY_FAULTSEQ", "API_OUTSEQ", "API_INSEQ", "API_FAULTSEQ", "AnonymousSequence"];
                var tableName = "MEDIATOR-STAT-PER-MINUTE";
                var query = stringify({
                                    "fieldName": "componentName",
                                    "query": "componentType : \"Sequence\""
                                  });
                var resp = connector.drillDownCategories(loggedInUser, tableName, query);
                var proxyNames = JSON.parse(resp.getMessage());

                for (var name in proxyNames["categories"]) {
                    result.push(name);
                }
                // Remove well-known sequences
                for(key in excludeSequences) {
                    var sequence = excludeSequences[key];
                    if (result.indexOf(sequence) != -1) {
                        result.splice(result.indexOf(sequence), 1);
                    }
                }
                break;
            }
            case TYPE_SEQUENCE_MESSAGE_RATE:
            {
                result = [];
                var timeUnit = 'MINUTE';
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                if (entryPoint == 'undefined') {
                    query = "_componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                } else {
                    query = "entryPoint : " + entryPoint + " AND _componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                }
                var tableName = "MEDIATOR-STAT-PER-" + timeUnit;
                query = stringify({
                                      tableName: tableName,
                                      groupByField: "facetStartTime",
                                      query: query,
                                      aggregateFields: [
                                          {
                                              fields: ["noOfInvocation"],
                                              aggregate: "SUM",
                                              alias: "total_invocation_sum"
                                          },
                                          {
                                              fields: ["faultCount"],
                                              aggregate: "SUM",
                                              alias: "total_fault_count"
                                          }
                                      ],
                                      aggregateLevel: 0,
                                      parentPath: []
                                  });
                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                                    "timestamp": obj.values.facetStartTime[0],
                                    "success": obj.values.total_invocation_sum,
                                    "faults": obj.values.total_fault_count
                                });
                }
                break;
            }
            case TYPE_SEQUENCE_LATENCY:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "MEDIATOR-STAT-PER-" + timeUnit;
                var componentName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                if (entryPoint == 'undefined') {
                    query = "_componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                } else {
                    query = "entryPoint : " + entryPoint + " AND _componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]";
                }
                query = stringify({
                                      tableName: tableName,
                                      query: query,
                                      start: 0,
                                      count: 60
                                  });
                resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                                    "timestamp": obj.values.facetStartTime,
                                    "min": obj.values.minDuration,
                                    "max": obj.values.maxDuration,
                                    "avg": obj.values.totalDuration / obj.values.noOfInvocation
                                });
                }
                break;
            }
            case TYPE_SEQUENCE_MESSAGES:
            {
                var result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var sequenceName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                var tableName = "ESB-EVENT";
                if (entryPoint != null && entryPoint != "undefined") {
                    var query = stringify({
                                      "query": "entryPoint : " + entryPoint + " AND componentType : \"Sequence\" AND _componentName : \"" + sequenceName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                } else {
                    var query = stringify({
                                      "query": "componentType : \"Sequence\" AND _componentName : \"" + sequenceName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                }
                
                var resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                var columns = ["messageFlowId", "faultCount","startTime","host"];
                for (i = 0 ; i < dataPoints.length ; i++) {
                    var temp = {};
                    for (j = 0 ; j < columns.length ; j++) {
                        var column = columns[j];
                        var value = dataPoints[i]["values"][column];
                        if (value != null && (column == "transportPropertyMap" || column == "contextPropertyMap")) {
                            temp[column] = stringify(value["map"]);
                        } else if (column == "faultCount") {
                            // Add message status
                            if (value > 0) {
                                temp["status"] = "Failed";
                            } else {
                                temp["status"] = "Success";
                            }   
                        }  else if (column == "startTime") {
                            var date = new Date(value);
                            temp[column] = date.toLocaleString();
                        } else {
                            temp[column] = value;
                        }
                    }
                    result.push(temp);
                }
                break;
            }
            case TYPE_SEQUENCE_MESSAGE_FLOW:
            {
                var result = [];
                var entryName = request.getParameter("id");
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                // get schema 
                var tableName = "ESB-CONFIG-ENTRY-STREAM";
                var query = stringify({
                                      "query": "_entryName : \"" + entryName + "\" AND _timestamp : [0000000000 TO " + timeTo + "] ",
                                      "start": 0,
                                      "count": 100,
                                      "sortBy" : [
                                            {
                                                "field" : "_timestamp",
                                                "sortType" : "DESC",
                                                "reversed" : "false"
                                            }
                                        ]
                                  });
                var resp = connector.search(loggedInUser, tableName, query);
                var config = JSON.parse(resp.getMessage())[0];
                if (config != null) {
                    var schema = JSON.parse(config["values"]["configData"]);
                    var entryHashCode = config["values"]["hashcode"];

                    // get components info from different tables
                    var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                    var searchParams = [];
                    var aggregateFields = [];
                    aggregateFields.push({fields: ["totalDuration"], aggregate: "SUM", alias: "TotalDuration"});
                    aggregateFields.push({fields: ["totalDuration"], aggregate: "MAX", alias: "MaxDuration"});
                    aggregateFields.push({fields: ["noOfInvocation"], aggregate: "SUM", alias: "Invocations"});
                    aggregateFields.push({fields: ["faultCount"], aggregate: "SUM", alias: "Faults"});
                    aggregateFields.push({fields: ["entryPoint"], aggregate: "FIRST", alias: "entryPoint"});
                    aggregateFields.push({fields: ["componentType"], aggregate: "FIRST", alias: "componentType"});
                    for (var i = 0; i < timeRanges.size(); i++) {
                        timeRange = timeRanges.get(i);
                        var searchParam = {
                            tableName: "MEDIATOR-STAT-PER-" + timeRange.unit,
                            groupByField: "componentId",
                            query: "hashCode : \"" + entryHashCode + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "}",
                            aggregateLevel: 0,
                            parentPath: [],
                            noOfRecords : 10000
                        }
                        searchParam.aggregateFields = aggregateFields;
                        searchParams.push(searchParam);
                    }
                    var resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));           
                    var allTables = JSON.parse(resp.getMessage());

                    // Aggregate all tables and prepare component map
                    var componentMap = {};
                    var fields = ["Invocations", "TotalDuration", "MaxDuration", "Faults"];
                    for (var i = 0; i < allTables.length; i++) {
                        var table = allTables[i];
                        if (table != null && table.length != 0) {
                            for (var j = 0; j < table.length; j++) {
                                var componentInfo = table[j]["values"];
                                var componentId = componentInfo["componentId"][0];
                                if (componentMap[componentId] == null) {
                                    componentMap[componentId] = componentInfo;
                                } else {
                                    for (field in fields) {
                                        fieldName = fields[field];
                                        componentMap[componentId][fieldName] = componentMap[componentId][fieldName] + componentInfo[fieldName];
                                    }
                                } 
                            }
                        }
                    }

                    // Populate tabel data
                    var componentNameRegex = new RegExp("^.*@\\d*:(.*)");
                    var groups = [];
                    for (var i = 0; i < schema.length; i++) {
                        var groupLabel;
                        var groupId = schema[i]["group"];
                        var componentId = schema[i]["id"];
                        var componentInfo = componentMap[componentId];
                        var dataAttributes = [];

                        // Find unique groups
                        if (schema[i]["group"] != null && groups.indexOf(schema[i]["group"]) == -1) {
                            groups.push(schema[i]["group"]);
                        }
                        
                        // Create data attributes
                        for (field in fields) {
                            var fieldName = fields[field];
                            if (componentInfo != null) {
                                if (fieldName == "TotalDuration") {
                                    dataAttributes.push({ "name" : "AvgDuration", "value" : (componentInfo[fieldName]/componentInfo["Invocations"]).toFixed(2)});
                                } else {
                                    dataAttributes.push({ "name" : fieldName, "value" : componentInfo[fieldName]});
                                }
                            } else {
                                dataAttributes.push({ "name" : fieldName, "value" : 0});
                            }  
                        }

                        var  componentLabel = componentNameRegex.exec(componentId)[1];
                        if (componentInfo != null ) {
                            componentType = componentInfo["componentType"];
                        } else {
                            componentType = "UNKNOWN";
                        }

                        // Create hidden attributes
                        var hiddenAttributes = [];
                        hiddenAttributes.push({"name" : "entryPoint", "value": componentMap[componentId]["entryPoint"]});
                        if (componentType == "Endpoint" || componentType == "Sequence") {
                            hiddenAttributes.push({ "name" : "id", "value": componentLabel});
                        } else {
                            hiddenAttributes.push({ "name" : "id", "value": componentId});
                        }

                        if (schema[i]["parentId"] == schema[i]["group"]) {
                            result.push({"id":componentId,
                                        "label" : componentLabel,
                                        "parents" : [],
                                        "group" : schema[i]["group"],
                                        "type": componentType,
                                        "dataAttributes":dataAttributes,
                                        "hiddenAttributes":hiddenAttributes
                                        });
                        } else {
                            result.push({"id":componentId,
                                        "label" : componentLabel,
                                        "parents" : [schema[i]["parentId"]],
                                        "group" : schema[i]["group"],
                                        "type": componentType,
                                        "dataAttributes":dataAttributes,
                                        "hiddenAttributes":hiddenAttributes
                                        });
                        }
                    }
                    // Defining groups
                    for (var j = 0 ; j < result.length ; j++) {
                        if(groups.indexOf(result[j]["id"]) >= 0) {
                            result[j]["type"] = "group";
                        }
                    }
                }
                break;
            }
            case TYPE_INBOUND_ENDPOINT_NAMES:
            {
                var result = [];
                var tableName = "ESB-STAT-PER-MINUTE";
                var query = stringify({
                                    "fieldName": "componentName",
                                    "query": "componentType : \"Inbound EndPoint\""
                                  });
                var resp = connector.drillDownCategories(loggedInUser, tableName, query);
                var proxyNames = JSON.parse(resp.getMessage());
                for (var name in proxyNames["categories"]) {
                    result.push(name);
                }
                break;
            }
            case TYPE_INBOUND_ENDPOINT_MESSAGE_RATE:
            {
                result = [];
                var timeUnit = 'MINUTE';
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "ESB-STAT-PER-" + timeUnit;
                query = stringify({
                                      tableName: tableName,
                                      groupByField: "facetStartTime",
                                      query: "_componentName : \"" + proxyName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]",
                                      aggregateFields: [
                                          {
                                              fields: ["noOfInvocation"],
                                              aggregate: "SUM",
                                              alias: "total_invocation_sum"
                                          },
                                          {
                                              fields: ["faultCount"],
                                              aggregate: "SUM",
                                              alias: "total_fault_count"
                                          }
                                      ],
                                      aggregateLevel: 0,
                                      parentPath: []
                                  });

                resp = connector.searchWithAggregates(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                                    "timestamp": obj.values.facetStartTime[0],
                                    "success": obj.values.total_invocation_sum,
                                    "faults": obj.values.total_fault_count
                                });
                }
                break;
            }
            case TYPE_INBOUND_ENDPOINT_LATENCY:
            {
                result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeUnit = timeRangeUtil.getSuitableTimeRangeUnit(timeFrom, timeTo);
                var tableName = "ESB-STAT-PER-" + timeUnit;
                var componentName = request.getParameter("id");
                query = stringify({
                                      tableName: tableName,
                                      query: "_componentName : \"" + componentName + "\" AND startingTime : [" + timeFrom + " TO " + timeTo + "]",
                                      start: 0,
                                      count: 60
                                  });
                resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    result.push({
                                    "timestamp": obj.values.facetStartTime,
                                    "min": obj.values.minDuration,
                                    "max": obj.values.maxDuration,
                                    "avg": obj.values.totalDuration / obj.values.noOfInvocation
                                });
                }
                break;
            }
            case TYPE_INBOUND_ENDPOINT_MESSAGES:
            {
                var result = [];
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var inboundEndpointName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                var tableName = "ESB-EVENT";
                if (entryPoint != null && entryPoint != "undefined") {
                    var query = stringify({
                                      "query": "entryPoint : " + entryPoint + " AND componentType : \"Inbound EndPoint\" AND _componentName : \"" + inboundEndpointName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                } else {
                    var query = stringify({
                                      "query": "componentType : \"Inbound EndPoint\" AND _componentName : \"" + inboundEndpointName + "\" AND startTime : [" + timeFrom + " TO " + timeTo + "]",
                                      "start": 0,
                                      "count": 100
                                  });
                }
                
                var resp = connector.search(loggedInUser, tableName, query);
                var dataPoints = JSON.parse(resp.getMessage());
                var columns = ["messageFlowId", "faultCount","startTime","host"];
                for (i = 0 ; i < dataPoints.length ; i++) {
                    var temp = {};
                    for (j = 0 ; j < columns.length ; j++) {
                        var column = columns[j];
                        var value = dataPoints[i]["values"][column];
                        if (value != null && (column == "transportPropertyMap" || column == "contextPropertyMap")) {
                            temp[column] = stringify(value["map"]);
                        } else if (column == "faultCount") {
                            // Add message status
                            if (value > 0) {
                                temp["status"] = "Failed";
                            } else {
                                temp["status"] = "Success";
                            }   
                        }  else if (column == "startTime") {
                            var date = new Date(value);
                            temp[column] = date.toLocaleString();
                        } else {
                            temp[column] = value;
                        }
                    }
                    result.push(temp);
                }
                break;
            }
            case TYPE_INBOUND_ENDPOINT_MESSAGE_FLOW:
            {
                var result = [];
                break;
            }
            case TYPE_OVERALL_STATS:
            {
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                var searchParams = [];
                var noOfInvocationSum = {
                    fields: ["noOfInvocation"],
                    aggregate: "SUM",
                    alias: "sum_no_of_invocation"
                }
                var faultCountSum = {
                    fields: ["faultCount"],
                    aggregate: "SUM",
                    alias: "sum_fault_count"
                }
                var aggregateFields = [];
                aggregateFields.push(noOfInvocationSum);
                aggregateFields.push(faultCountSum);
                for (var i = 0; i < timeRanges.size(); i++) {
                    timeRange = timeRanges.get(i);
                    var searchParam = {
                        tableName: "ESB-STAT-PER-" + timeRange.unit,
                        query: "startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "}",
                        aggregateLevel: 0,
                        parentPath: [],
                        noOfRecords: 1000
                    }
                    searchParam.aggregateFields = aggregateFields;
                    searchParams.push(searchParam);
                }
                resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));
                var totalInvocation = 0;
                var totalFault = 0;
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (obj.length != 0) {
                        totalInvocation += obj[0].values.sum_no_of_invocation;
                        totalFault += obj[0].values.sum_fault_count;
                    }
                }
                result = {total: totalInvocation, failed: totalFault};
                break;
            }
            case TYPE_PROXY_STATS:
            {
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                var searchParams = [];
                var noOfInvocationSum = {
                    fields: ["noOfInvocation"],
                    aggregate: "SUM",
                    alias: "sum_no_of_invocation"
                }
                var faultCountSum = {
                    fields: ["faultCount"],
                    aggregate: "SUM",
                    alias: "sum_fault_count"
                }
                var aggregateFields = [];
                aggregateFields.push(noOfInvocationSum);
                aggregateFields.push(faultCountSum);
                for (var i = 0; i < timeRanges.size(); i++) {
                    timeRange = timeRanges.get(i);
                    var searchParam = {
                        tableName: "ESB-STAT-PER-" + timeRange.unit,
                        query: "_componentName : \"" + componentName + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "}",
                        aggregateLevel: 0,
                        parentPath: [],
                        noOfRecords: 1000
                    }
                    searchParam.aggregateFields = aggregateFields;
                    searchParams.push(searchParam);
                }
                resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));
                var totalInvocation = 0;
                var totalFault = 0;
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (obj.length != 0) {
                        totalInvocation += obj[0].values.sum_no_of_invocation;
                        totalFault += obj[0].values.sum_fault_count;
                    }
                }
                result = {total: totalInvocation, failed: totalFault};
                break;
            }
            case TYPE_API_STATS:
            {
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                var searchParams = [];
                var noOfInvocationSum = {
                    fields: ["noOfInvocation"],
                    aggregate: "SUM",
                    alias: "sum_no_of_invocation"
                }
                var faultCountSum = {
                    fields: ["faultCount"],
                    aggregate: "SUM",
                    alias: "sum_fault_count"
                }
                var aggregateFields = [];
                aggregateFields.push(noOfInvocationSum);
                aggregateFields.push(faultCountSum);
                for (var i = 0; i < timeRanges.size(); i++) {
                    timeRange = timeRanges.get(i);
                    var searchParam = {
                        tableName: "ESB-STAT-PER-" + timeRange.unit,
                        query: "_componentName : \"" + componentName + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "}",
                        aggregateLevel: 0,
                        parentPath: [],
                        noOfRecords: 1000
                    }
                    searchParam.aggregateFields = aggregateFields;
                    searchParams.push(searchParam);
                }
                resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));
                var totalInvocation = 0;
                var totalFault = 0;
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (obj.length != 0) {
                        totalInvocation += obj[0].values.sum_no_of_invocation;
                        totalFault += obj[0].values.sum_fault_count;
                    }
                }
                result = {total: totalInvocation, failed: totalFault};
                break;
            }
            case TYPE_SEQUENCE_STATS:
            {
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                var searchParams = [];
                var noOfInvocationSum = {
                    fields: ["noOfInvocation"],
                    aggregate: "SUM",
                    alias: "sum_no_of_invocation"
                }
                var faultCountSum = {
                    fields: ["faultCount"],
                    aggregate: "SUM",
                    alias: "sum_fault_count"
                }
                var aggregateFields = [];
                aggregateFields.push(noOfInvocationSum);
                aggregateFields.push(faultCountSum);
                for (var i = 0; i < timeRanges.size(); i++) {
                    timeRange = timeRanges.get(i);
                    if (entryPoint == 'undefined') {
                        query = "_componentName : \"" + componentName + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "]";
                    } else {
                        query = "entryPoint : " + entryPoint + " AND _componentName : \"" + componentName + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "]";
                    }
                    var searchParam = {
                        tableName: "MEDIATOR-STAT-PER-" + timeRange.unit,
                        query: query,
                        aggregateLevel: 0,
                        parentPath: [],
                        noOfRecords: 1000
                    }
                    searchParam.aggregateFields = aggregateFields;
                    searchParams.push(searchParam);
                }
                resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));
                var totalInvocation = 0;
                var totalFault = 0;
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (obj.length != 0) {
                        totalInvocation += obj[0].values.sum_no_of_invocation;
                        totalFault += obj[0].values.sum_fault_count;
                    }
                }
                result = {total: totalInvocation, failed: totalFault};
                break;
            }
            case TYPE_ENDPOINT_STATS:
            {
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                var searchParams = [];
                var noOfInvocationSum = {
                    fields: ["noOfInvocation"],
                    aggregate: "SUM",
                    alias: "sum_no_of_invocation"
                }
                var faultCountSum = {
                    fields: ["faultCount"],
                    aggregate: "SUM",
                    alias: "sum_fault_count"
                }
                var aggregateFields = [];
                aggregateFields.push(noOfInvocationSum);
                aggregateFields.push(faultCountSum);
                for (var i = 0; i < timeRanges.size(); i++) {
                    timeRange = timeRanges.get(i);
                    var searchParam = {
                        tableName: "ESB-STAT-PER-" + timeRange.unit,
                        query: "_componentName : \"" + componentName + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "}",
                        aggregateLevel: 0,
                        parentPath: [],
                        noOfRecords: 1000
                    }
                    searchParam.aggregateFields = aggregateFields;
                    searchParams.push(searchParam);
                }
                resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));
                var totalInvocation = 0;
                var totalFault = 0;
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (obj.length != 0) {
                        totalInvocation += obj[0].values.sum_no_of_invocation;
                        totalFault += obj[0].values.sum_fault_count;
                    }
                }
                result = {total: totalInvocation, failed: totalFault};
                break;
            }
            case TYPE_INBOUND_ENDPOINT_STATS:
            {
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentName = request.getParameter("id");
                var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                var searchParams = [];
                var noOfInvocationSum = {
                    fields: ["noOfInvocation"],
                    aggregate: "SUM",
                    alias: "sum_no_of_invocation"
                }
                var faultCountSum = {
                    fields: ["faultCount"],
                    aggregate: "SUM",
                    alias: "sum_fault_count"
                }
                var aggregateFields = [];
                aggregateFields.push(noOfInvocationSum);
                aggregateFields.push(faultCountSum);
                for (var i = 0; i < timeRanges.size(); i++) {
                    timeRange = timeRanges.get(i);
                    var searchParam = {
                        tableName: "ESB-STAT-PER-" + timeRange.unit,
                        query: "_componentName : \"" + componentName + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "}",
                        aggregateLevel: 0,
                        parentPath: [],
                        noOfRecords: 1000
                    }
                    searchParam.aggregateFields = aggregateFields;
                    searchParams.push(searchParam);
                }
                resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));
                var totalInvocation = 0;
                var totalFault = 0;
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (obj.length != 0) {
                        totalInvocation += obj[0].values.sum_no_of_invocation;
                        totalFault += obj[0].values.sum_fault_count;
                    }
                }
                result = {total: totalInvocation, failed: totalFault};
                break;
            }case TYPE_MEDIATOR_STATS:
            {
                var timeFrom = request.getParameter("timeFrom");
                var timeTo = request.getParameter("timeTo");
                var componentId = request.getParameter("id");
                var entryPoint = request.getParameter("entryPoint");
                var timeRanges = timeRangeUtil.getDateTimeRanges(timeFrom, timeTo);
                var searchParams = [];
                var noOfInvocationSum = {
                    fields: ["noOfInvocation"],
                    aggregate: "SUM",
                    alias: "sum_no_of_invocation"
                }
                var faultCountSum = {
                    fields: ["faultCount"],
                    aggregate: "SUM",
                    alias: "sum_fault_count"
                }
                var aggregateFields = [];
                aggregateFields.push(noOfInvocationSum);
                aggregateFields.push(faultCountSum);
                for (var i = 0; i < timeRanges.size(); i++) {
                    timeRange = timeRanges.get(i);
                    if (entryPoint == 'undefined') {
                        query = "_componentId : \"" + componentId + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "]";
                    } else {
                        query = "entryPoint : " + entryPoint + " AND _componentId : \"" + componentId + "\" AND startingTime : [" + timeRange.range[0] + " TO " + timeRange.range[1] + "]";
                    }
                    var searchParam = {
                        tableName: "MEDIATOR-STAT-PER-" + timeRange.unit,
                        query: query,
                        aggregateLevel: 0,
                        parentPath: [],
                        noOfRecords: 1000
                    }
                    searchParam.aggregateFields = aggregateFields;
                    searchParams.push(searchParam);
                }
                resp = connector.searchMultiTablesWithAggregates(loggedInUser, JSON.stringify(searchParams));
                var totalInvocation = 0;
                var totalFault = 0;
                var dataPoints = JSON.parse(resp.getMessage());
                for (var i = 0; i < dataPoints.length; i++) {
                    var obj = dataPoints[i];
                    if (obj.length != 0) {
                        totalInvocation += obj[0].values.sum_no_of_invocation;
                        totalFault += obj[0].values.sum_fault_count;
                    }
                }
                result = {total: totalInvocation, failed: totalFault};
                break;
            }case TYPE_TOP_INVOKED_ENDPOINTS:
            {
                var result = [{ name : "Endpoint1", requests: 12345}];
                break;
            }
            case TYPE_TOP_INVOKED_INBOUNDS:
            {
                var result = [{ name : "Inbound1", requests: 12345}];
                break;
            }
            case TYPE_TOP_INVOKED_SEQUENCES:
            {
                var result = [{ name : "Sequence1", requests: 12345}];
                break;
            }
            default:
            {
                result = '{ "status": "Failed", "message": "Unidentified operation" }';
            }
        }
        if (result != null) {
            if (log.isDebugEnabled()) {
                log.debug("value of result: " + result);
            }
            var finalResult = {
                status: "success",
                message: result
            }
            print(finalResult);
        }
    } else {
        print('{ "status": "Failed", "statusCode": "500", "message": "AnalyticsCachedWebServiceConnector is unavailable" }');
    }

}());
%>